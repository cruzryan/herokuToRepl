import { api } from '@replit/protocol';
import { Channel } from './channel';
import { ConnectionState } from './types';
import type { GovalMetadata, OpenChannelCb, ChannelOptions, DebugLog, OpenOptions } from './types';
export declare class Client<Ctx = null> {
    connectionState: ConnectionState;
    private ws;
    private connectOptions;
    private chan0Cb;
    private chan0CleanupCb;
    private channelRequests;
    private channels;
    private debugFuncs;
    private bootStatusFuncs;
    private userUnrecoverableErrorHandler;
    private retryTimeoutId;
    private connectTimeoutId;
    private fetchTokenAbortController;
    private destroyed;
    private connectionMetadata;
    private redirectInitiatorURL;
    constructor();
    open: (options: OpenOptions<Ctx>, cb: OpenChannelCb<Ctx>) => void;
    openChannel: (options: ChannelOptions<Ctx>, cb: OpenChannelCb<Ctx>) => (() => void);
    private requestOpenChannel;
    private requestCloseChannel;
    close: () => void;
    destroy: () => void;
    getChannel: (id: number) => Channel;
    private debug;
    onDebugLog: (debugFunc: (log: DebugLog<Ctx>) => void) => (() => void);
    onBootStatus: (bootStatusFunc: (command: api.BootStatus) => void) => (() => void);
    onFirewallDenied: () => void;
    setUnrecoverableErrorHandler: (onUnrecoverableError: (e: Error) => void) => void;
    getConnectionMetadata: () => GovalMetadata | null;
    private connect;
    private retryConnect;
    private send;
    private onSocketMessage;
    private handleConnect;
    private handleClose;
    private cleanupSocket;
    private onUnrecoverableError;
    private redirectInitiatorFallback;
    private handleRedirect;
}
