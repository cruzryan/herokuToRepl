"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var protocol_1 = require("@replit/protocol");
var channel_1 = require("./channel");
var helpers_1 = require("./util/helpers");
var EIOCompat_1 = require("./util/EIOCompat");
var types_1 = require("./types");
var MAX_RETRY_COUNT = 10;
var ClientCloseReason;
(function (ClientCloseReason) {
    ClientCloseReason["Intentional"] = "Intentional";
    ClientCloseReason["Disconnected"] = "Disconnected";
    ClientCloseReason["Error"] = "Error";
})(ClientCloseReason || (ClientCloseReason = {}));
var Client = (function () {
    function Client() {
        var _this = this;
        this.open = function (options, cb) {
            if (_this.chan0Cb) {
                var error = new Error('You must call `close` before opening the client again');
                _this.onUnrecoverableError(error);
                throw error;
            }
            if (_this.destroyed) {
                var error = new Error('Client has been destroyed and cannot be re-used');
                _this.onUnrecoverableError(error);
                throw error;
            }
            _this.connectOptions = __assign({ timeout: 10000, reuseConnectionMetadata: false, getNextRetryDelayMs: helpers_1.defaultGetNextRetryDelay }, options);
            _this.debug({
                type: 'breadcrumb',
                message: 'open',
                data: { polling: false },
            });
            _this.chan0Cb = cb;
            _this.connect({ tryCount: 0, websocketFailureCount: 0 });
        };
        this.openChannel = function (options, cb) {
            var sameNameChanRequests = options.name
                ? _this.channelRequests.filter(function (cr) { return cr.options.name === options.name; })
                : [];
            if (sameNameChanRequests.some(function (cr) { return !cr.closeRequested; })) {
                var error = new Error("Channel with name ".concat(options.name, " already opened"));
                _this.onUnrecoverableError(error);
                throw error;
            }
            if (_this.destroyed) {
                var error = new Error('Client has been destroyed and is unusable');
                _this.onUnrecoverableError(error);
                throw error;
            }
            var channelRequest = {
                options: options,
                openChannelCb: cb,
                isOpen: false,
                channelId: null,
                cleanupCb: null,
                closeRequested: false,
            };
            _this.channelRequests.push(channelRequest);
            if (_this.connectionState === types_1.ConnectionState.CONNECTED && !sameNameChanRequests.length) {
                _this.requestOpenChannel(channelRequest);
            }
            var closeChannel = function () {
                if (channelRequest.closeRequested) {
                    return;
                }
                channelRequest.closeRequested = true;
                if (!channelRequest.isOpen) {
                    if (_this.connectionState !== types_1.ConnectionState.CONNECTED) {
                        _this.channelRequests = _this.channelRequests.filter(function (cr) { return cr !== channelRequest; });
                        channelRequest.openChannelCb({
                            error: new Error('Channel closed before opening'),
                            channel: null,
                            context: _this.connectOptions ? _this.connectOptions.context : null,
                        });
                    }
                    return;
                }
                _this.requestCloseChannel(channelRequest);
            };
            return closeChannel;
        };
        this.requestOpenChannel = function (channelRequest) {
            var options = channelRequest.options, openChannelCb = channelRequest.openChannelCb;
            if (!_this.connectOptions) {
                _this.onUnrecoverableError(new Error('Expected connectionOptions'));
                return;
            }
            var skip = options.skip;
            if (skip && skip(_this.connectOptions.context)) {
                return;
            }
            var action = options.action;
            if (!action) {
                action =
                    options.name == null
                        ? protocol_1.api.OpenChannel.Action.CREATE
                        : protocol_1.api.OpenChannel.Action.ATTACH_OR_CREATE;
            }
            if (channelRequest.channelId) {
                _this.onUnrecoverableError(new Error('Unexpected channelId'));
                return;
            }
            var service = typeof options.service === 'string'
                ? options.service
                : options.service(_this.connectOptions.context);
            _this.debug({
                type: 'breadcrumb',
                message: 'requestOpenChannel',
                data: {
                    name: options.name,
                    service: service,
                    action: action,
                },
            });
            var chan0 = _this.getChannel(0);
            var ref = Number(Math.random().toString().split('.')[1]).toString(36);
            chan0.send({
                ref: ref,
                openChan: {
                    name: options.name,
                    service: service,
                    action: action,
                },
            });
            var dispose = chan0.onCommand(function (cmd) {
                if (ref !== cmd.ref) {
                    return;
                }
                dispose();
                if (cmd.openChanRes == null) {
                    _this.onUnrecoverableError(new Error('Expected openChanRes on command'));
                    return;
                }
                var _a = cmd.openChanRes, id = _a.id, state = _a.state, error = _a.error;
                _this.debug({ type: 'breadcrumb', message: 'openChanres' });
                if (!_this.connectOptions) {
                    _this.onUnrecoverableError(new Error('Expected connectionOptions'));
                    return;
                }
                if (state === protocol_1.api.OpenChannelRes.State.ERROR) {
                    _this.onUnrecoverableError(new Error("Channel open resulted with an error: ".concat(error || 'with no message')));
                    return;
                }
                if (typeof id !== 'number' || typeof state !== 'number') {
                    _this.onUnrecoverableError(new Error('Expected state and channel id'));
                    return;
                }
                var channel = new channel_1.Channel({
                    id: id,
                    name: channelRequest.options.name,
                    service: service,
                    onUnrecoverableError: _this.onUnrecoverableError,
                    send: _this.send,
                });
                _this.channels[id] = channel;
                channelRequest.channelId = id;
                channelRequest.isOpen = true;
                var closeRequested = channelRequest.closeRequested;
                if (closeRequested) {
                    _this.requestCloseChannel(channelRequest);
                }
                channelRequest.cleanupCb = openChannelCb({
                    channel: channel,
                    error: null,
                    context: _this.connectOptions.context,
                });
            });
        };
        this.requestCloseChannel = function (channelRequest) { return __awaiter(_this, void 0, void 0, function () {
            var channelId, chan, chan0, res, id, nextRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!channelRequest.isOpen) {
                            this.onUnrecoverableError(new Error('Tried to request a channel close before opening'));
                            return [2];
                        }
                        channelId = channelRequest.channelId;
                        chan = this.getChannel(channelRequest.channelId);
                        chan.status = 'closing';
                        chan0 = this.getChannel(0);
                        if (!chan0) {
                            this.onUnrecoverableError(new Error('Tried to request a channel close but there was no chan0'));
                            return [2];
                        }
                        this.debug({
                            type: 'breadcrumb',
                            message: 'requestChannelClose',
                            data: {
                                id: channelId,
                                name: channelRequest.options.name,
                                service: channelRequest.options.service,
                            },
                        });
                        return [4, chan0.request({
                                closeChan: {
                                    action: protocol_1.api.CloseChannel.Action.TRY_CLOSE,
                                    id: channelRequest.channelId,
                                },
                            })];
                    case 1:
                        res = _a.sent();
                        if (res.channelClosed) {
                            this.debug({
                                type: 'breadcrumb',
                                message: 'requestChannelClose:chan0Closed',
                                data: {
                                    id: channelId,
                                    name: channelRequest.options.name,
                                    service: channelRequest.options.service,
                                },
                            });
                        }
                        else {
                            if (res.closeChanRes == null) {
                                this.onUnrecoverableError(new Error('Expected closeChanRes'));
                                return [2];
                            }
                            id = res.closeChanRes.id;
                            if (id == null) {
                                this.onUnrecoverableError(new Error("Expected id, got ".concat(id)));
                                return [2];
                            }
                            if (id !== channelId) {
                                this.onUnrecoverableError(new Error("Expected id from closeChanRes to be ".concat(channelId, " got ").concat(id)));
                                return [2];
                            }
                            this.debug({
                                type: 'breadcrumb',
                                message: 'requestChannelClose:closeChanRes',
                                data: {
                                    id: channelId,
                                    name: channelRequest.options.name,
                                    service: channelRequest.options.service,
                                    closeStatus: res.closeChanRes.status,
                                },
                            });
                        }
                        this.channelRequests = this.channelRequests.filter(function (cr) { return cr !== channelRequest; });
                        delete this.channels[channelId];
                        chan.handleClose({ initiator: 'channel', willReconnect: false });
                        if (channelRequest.cleanupCb) {
                            channelRequest.cleanupCb({ initiator: 'channel', willReconnect: false });
                        }
                        if (!channelRequest.options.name || this.connectionState !== types_1.ConnectionState.CONNECTED) {
                            return [2];
                        }
                        nextRequest = this.channelRequests.find(function (cr) { return cr.options.name === channelRequest.options.name; });
                        if (!nextRequest) {
                            return [2];
                        }
                        this.requestOpenChannel(nextRequest);
                        return [2];
                }
            });
        }); };
        this.close = function () {
            _this.debug({ type: 'breadcrumb', message: 'user close' });
            if (!_this.chan0Cb || !_this.connectOptions) {
                var error = new Error('Must call client.open before closing');
                _this.onUnrecoverableError(error);
                throw error;
            }
            _this.connectionMetadata = null;
            _this.handleClose({ closeReason: ClientCloseReason.Intentional });
        };
        this.destroy = function () {
            _this.destroyed = true;
            _this.debug({ type: 'breadcrumb', message: 'destroy' });
            if (_this.connectionState !== types_1.ConnectionState.DISCONNECTED) {
                _this.close();
            }
            _this.debug = function () { };
            _this.userUnrecoverableErrorHandler = null;
            _this.channelRequests = [];
            _this.destroyed = true;
        };
        this.getChannel = function (id) {
            var chan = _this.channels[id];
            if (!chan) {
                var error = new Error("No channel with number ".concat(id));
                _this.onUnrecoverableError(error);
                throw error;
            }
            return chan;
        };
        this.debug = function (log) {
            _this.debugFuncs.forEach(function (func) { return func(log); });
        };
        this.onDebugLog = function (debugFunc) {
            _this.debugFuncs.push(debugFunc);
            return function () {
                var idx = _this.debugFuncs.indexOf(debugFunc);
                if (idx > -1) {
                    _this.debugFuncs.splice(idx, 1);
                }
            };
        };
        this.onBootStatus = function (bootStatusFunc) {
            _this.bootStatusFuncs.push(bootStatusFunc);
            return function () {
                var idx = _this.bootStatusFuncs.indexOf(bootStatusFunc);
                if (idx > -1) {
                    _this.bootStatusFuncs.splice(idx, 1);
                }
            };
        };
        this.onFirewallDenied = function () {
            _this.onUnrecoverableError(new Error("Can't connect to unfirewalled repl from firewall mode"));
        };
        this.setUnrecoverableErrorHandler = function (onUnrecoverableError) {
            _this.userUnrecoverableErrorHandler = onUnrecoverableError;
        };
        this.getConnectionMetadata = function () { return _this.connectionMetadata; };
        this.connect = function (_a) {
            var tryCount = _a.tryCount, websocketFailureCount = _a.websocketFailureCount;
            return __awaiter(_this, void 0, void 0, function () {
                var error, error, error, chan0, abortController, connectionMetadataFetchResult, e_1, err, connectionMetadata, aborted, isPolling, WebSocketClass, connStr, ws, didWebsocketsWork, didReceiveAnyCommand, onFailed, resetTimeout, cancelTimeout, timeout, unlistenChan0, currentChan0, currentConnectOptions;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.debug({
                                type: 'breadcrumb',
                                message: 'connecting',
                                data: {
                                    connectionState: this.connectionState,
                                    connectTries: tryCount,
                                    websocketFailureCount: websocketFailureCount,
                                    readyState: this.ws ? this.ws.readyState : undefined,
                                    chan0CbExists: Boolean(this.chan0Cb),
                                },
                            });
                            if (this.connectionState !== types_1.ConnectionState.DISCONNECTED) {
                                error = new Error('Client must be disconnected to connect');
                                this.onUnrecoverableError(error);
                                throw error;
                            }
                            if (this.ws) {
                                error = new Error('Unexpected existing websocket instance');
                                this.onUnrecoverableError(error);
                                throw error;
                            }
                            if (!this.connectOptions) {
                                error = new Error('Expected connectionOptions');
                                this.onUnrecoverableError(error);
                                throw error;
                            }
                            if (!this.chan0Cb) {
                                this.onUnrecoverableError(new Error('Expected chan0Cb'));
                                return [2];
                            }
                            if (this.chan0CleanupCb) {
                                this.onUnrecoverableError(new Error('Unexpected chan0CleanupCb, are you sure you closed'));
                                return [2];
                            }
                            if (this.channelRequests.some(function (cr) { return cr.isOpen; })) {
                                this.onUnrecoverableError(new Error('All channels should be closed when we connect'));
                                return [2];
                            }
                            if (Object.keys(this.channels).length) {
                                this.onUnrecoverableError(new Error('Found an an unexpected existing channels'));
                                return [2];
                            }
                            if (this.connectTimeoutId) {
                                this.onUnrecoverableError(new Error('Unexpected connectTimeoutId'));
                                return [2];
                            }
                            this.connectionState = types_1.ConnectionState.CONNECTING;
                            chan0 = new channel_1.Channel({
                                id: 0,
                                name: 'chan0',
                                onUnrecoverableError: this.onUnrecoverableError,
                                send: this.send,
                            });
                            this.channels[0] = chan0;
                            chan0.onCommand(function (cmd) {
                                var bootStatus = cmd.bootStatus;
                                if (bootStatus != null) {
                                    _this.bootStatusFuncs.forEach(function (cb) { return cb(bootStatus); });
                                }
                            });
                            chan0.onCommand(function (cmd) {
                                var redirect = cmd.redirect;
                                if (redirect != null) {
                                    return _this.handleRedirect(redirect.url);
                                }
                            });
                            if (!(!this.connectOptions.reuseConnectionMetadata || this.connectionMetadata === null)) return [3, 5];
                            if (this.fetchTokenAbortController) {
                                this.onUnrecoverableError(new Error('Expected fetchTokenAbortController to be null'));
                                return [2];
                            }
                            abortController = new AbortController();
                            this.fetchTokenAbortController = abortController;
                            connectionMetadataFetchResult = void 0;
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4, this.connectOptions.fetchConnectionMetadata(abortController.signal)];
                        case 2:
                            connectionMetadataFetchResult = _b.sent();
                            return [3, 4];
                        case 3:
                            e_1 = _b.sent();
                            err = void 0;
                            if (e_1 instanceof Error) {
                                err = e_1;
                            }
                            else if (e_1 &&
                                typeof e_1 === 'object' &&
                                'message' in e_1 &&
                                typeof e_1.message === 'string') {
                                err = new Error(e_1.message);
                            }
                            else if (typeof e_1 === 'string') {
                                err = new Error(e_1);
                            }
                            else {
                                err = new Error('Unknown error when fetching connection metadata');
                            }
                            this.onUnrecoverableError(err);
                            return [2];
                        case 4:
                            this.fetchTokenAbortController = null;
                            connectionMetadata = connectionMetadataFetchResult;
                            aborted = connectionMetadata.error === types_1.FetchConnectionMetadataError.Aborted;
                            if (abortController.signal.aborted !== aborted) {
                                if (abortController.signal.aborted) {
                                    this.onUnrecoverableError(new Error('Expected abort returned from fetchConnectionMetadata to be truthy when the controller aborts'));
                                    return [2];
                                }
                                this.onUnrecoverableError(new Error('Abort should only be truthy returned when the abort signal is triggered'));
                                return [2];
                            }
                            if (connectionMetadata.error === types_1.FetchConnectionMetadataError.Aborted) {
                                return [2];
                            }
                            if (connectionMetadata.error === types_1.FetchConnectionMetadataError.Retriable) {
                                this.retryConnect({
                                    tryCount: tryCount + 1,
                                    websocketFailureCount: websocketFailureCount,
                                    chan0: chan0,
                                    error: new Error('Retriable error'),
                                });
                                return [2];
                            }
                            if (this.connectionState !== types_1.ConnectionState.CONNECTING) {
                                this.onUnrecoverableError(new Error('Client was closed before connecting'));
                                return [2];
                            }
                            if (connectionMetadata.error) {
                                this.onUnrecoverableError(connectionMetadata.error);
                                return [2];
                            }
                            this.connectionMetadata = connectionMetadata;
                            _b.label = 5;
                        case 5:
                            if (websocketFailureCount === 3 && this.connectOptions.pollingHost) {
                                this.debug({
                                    type: 'breadcrumb',
                                    message: 'polling fallback',
                                });
                            }
                            isPolling = websocketFailureCount >= 3 && this.connectOptions.pollingHost;
                            WebSocketClass = isPolling
                                ? EIOCompat_1.EIOCompat
                                : (0, helpers_1.getWebSocketClass)(this.connectOptions.WebSocketClass);
                            connStr = (0, helpers_1.getConnectionStr)(this.connectionMetadata, isPolling ? this.connectOptions.pollingHost : undefined);
                            ws = new WebSocketClass(connStr);
                            ws.binaryType = 'arraybuffer';
                            ws.onmessage = this.onSocketMessage;
                            this.ws = ws;
                            didWebsocketsWork = false;
                            didReceiveAnyCommand = false;
                            onFailed = null;
                            ws.onerror = function () {
                                if (!onFailed) {
                                    _this.onUnrecoverableError(new Error('Got websocket error but no `onFailed` cb'));
                                    return;
                                }
                                onFailed(new Error('WebSocket errored'));
                            };
                            ws.onclose = function (event) {
                                if (!onFailed) {
                                    _this.onUnrecoverableError(new Error('Got websocket closure but no `onFailed` cb'));
                                    return;
                                }
                                var retriable = true;
                                if (WebSocketClass === EIOCompat_1.EIOCompat) {
                                    if (!didReceiveAnyCommand) {
                                        _this.connectionMetadata = null;
                                    }
                                }
                                else if ('code' in event) {
                                    var closeEvent = event;
                                    if (closeEvent.code === types_1.CloseCode.POLICY_VIOLATION) {
                                        _this.connectionMetadata = null;
                                    }
                                    if (closeEvent.code === types_1.CloseCode.USER_ERROR ||
                                        closeEvent.code === types_1.CloseCode.FIREWALL_DENIED) {
                                        retriable = false;
                                    }
                                }
                                onFailed(new Error('WebSocket closed before we got READY'), retriable);
                            };
                            ws.onopen = function () {
                                if (WebSocketClass === EIOCompat_1.EIOCompat) {
                                    return;
                                }
                                didWebsocketsWork = true;
                            };
                            resetTimeout = function () { };
                            cancelTimeout = function () { };
                            timeout = this.connectOptions.timeout;
                            if (timeout !== null) {
                                cancelTimeout = function () {
                                    _this.debug({ type: 'breadcrumb', message: 'cancel timeout' });
                                    if (_this.connectTimeoutId) {
                                        clearTimeout(_this.connectTimeoutId);
                                        _this.connectTimeoutId = null;
                                    }
                                };
                                resetTimeout = function () {
                                    _this.debug({ type: 'breadcrumb', message: 'reset timeout' });
                                    if (_this.connectTimeoutId) {
                                        clearTimeout(_this.connectTimeoutId);
                                    }
                                    _this.connectTimeoutId = setTimeout(function () {
                                        _this.debug({ type: 'breadcrumb', message: 'connect timeout' });
                                        if (!onFailed) {
                                            _this.onUnrecoverableError(new Error('Connecting timed out but there was no `onFailed` cb'));
                                            return;
                                        }
                                        onFailed(new Error('timeout'));
                                    }, timeout);
                                };
                                resetTimeout();
                            }
                            unlistenChan0 = chan0.onCommand(function (cmd) {
                                didReceiveAnyCommand = true;
                                resetTimeout();
                                if (cmd.firewallDenied != null) {
                                    _this.onFirewallDenied();
                                    return;
                                }
                                if (cmd.containerState == null) {
                                    return;
                                }
                                if (cmd.containerState.state == null) {
                                    _this.onUnrecoverableError(new Error('Got containterState but state was not defined'));
                                    return;
                                }
                                var state = cmd.containerState.state;
                                _this.debug({
                                    type: 'breadcrumb',
                                    message: 'containerState',
                                    data: state,
                                });
                                var StateEnum = protocol_1.api.ContainerState.State;
                                switch (state) {
                                    case StateEnum.READY: {
                                        unlistenChan0();
                                        cancelTimeout();
                                        if (!_this.connectOptions) {
                                            _this.onUnrecoverableError(new Error('Expected connectionOptions'));
                                            return;
                                        }
                                        if (!chan0) {
                                            _this.onUnrecoverableError(new Error('Expected chan0 to be truthy'));
                                            return;
                                        }
                                        if (!_this.chan0Cb) {
                                            _this.onUnrecoverableError(new Error('Expected chan0Cb to be truthy'));
                                            return;
                                        }
                                        _this.handleConnect();
                                        var originalClose_1 = _this.close;
                                        _this.close = function () {
                                            return setTimeout(function () {
                                                originalClose_1();
                                            }, 0);
                                        };
                                        _this.chan0CleanupCb = _this.chan0Cb({
                                            channel: chan0,
                                            error: null,
                                            context: _this.connectOptions.context,
                                        });
                                        _this.close = originalClose_1;
                                        break;
                                    }
                                    case StateEnum.SLEEP:
                                        if (!onFailed) {
                                            _this.onUnrecoverableError(new Error('Got SLEEP but there was no `onFailed` cb'));
                                            return;
                                        }
                                        onFailed(new Error('Got SLEEP as container state'));
                                        break;
                                    default:
                                }
                            });
                            currentChan0 = this.getChannel(0);
                            currentConnectOptions = this.connectOptions;
                            onFailed = function (error, retriable) {
                                if (retriable === void 0) { retriable = true; }
                                onFailed = null;
                                _this.cleanupSocket();
                                cancelTimeout();
                                unlistenChan0();
                                if (_this.connectOptions !== currentConnectOptions || _this.getChannel(0) !== currentChan0) {
                                    _this.onUnrecoverableError(new Error('onFailed got called but client is in a different connecting context'));
                                    return;
                                }
                                if (!retriable) {
                                    _this.onUnrecoverableError(error);
                                    return;
                                }
                                _this.retryConnect({
                                    tryCount: tryCount + 1,
                                    websocketFailureCount: didWebsocketsWork ? 0 : websocketFailureCount + 1,
                                    chan0: chan0,
                                    error: error,
                                });
                            };
                            return [2];
                    }
                });
            });
        };
        this.retryConnect = function (_a) {
            var tryCount = _a.tryCount, websocketFailureCount = _a.websocketFailureCount, chan0 = _a.chan0, error = _a.error;
            if (_this.retryTimeoutId) {
                _this.onUnrecoverableError(new Error('Unexpected existing retryTimeoutId'));
                return;
            }
            if (!_this.chan0Cb) {
                _this.onUnrecoverableError(new Error('Expected chan0Cb when scheduling a retry'));
                return;
            }
            if (!_this.connectOptions) {
                _this.onUnrecoverableError(new Error('Expected connectOptions when scheduling a retry'));
                return;
            }
            if (tryCount >= MAX_RETRY_COUNT && _this.redirectInitiatorURL) {
                _this.debug({
                    type: 'breadcrumb',
                    message: 'redirectInitiatorFallback',
                    data: {
                        connectionState: _this.connectionState,
                        connectTries: tryCount,
                        websocketFailureCount: websocketFailureCount,
                        error: error,
                        wsReadyState: _this.ws ? _this.ws.readyState : undefined,
                    },
                });
                return _this.redirectInitiatorFallback();
            }
            _this.retryTimeoutId = setTimeout(function () {
                if (!_this.chan0Cb) {
                    _this.onUnrecoverableError(new Error('Scheduled retry is called after we closed?'));
                    return;
                }
                _this.retryTimeoutId = null;
                _this.debug({
                    type: 'breadcrumb',
                    message: 'retrying',
                    data: {
                        connectionState: _this.connectionState,
                        connectTries: tryCount,
                        websocketFailureCount: websocketFailureCount,
                        error: error,
                        wsReadyState: _this.ws ? _this.ws.readyState : undefined,
                    },
                });
                chan0.handleClose({ initiator: 'client', willReconnect: true });
                delete _this.channels[0];
                _this.connectionState = types_1.ConnectionState.DISCONNECTED;
                _this.connect({ tryCount: tryCount, websocketFailureCount: websocketFailureCount });
            }, _this.connectOptions.getNextRetryDelayMs(tryCount));
        };
        this.send = function (cmd) {
            var channel = _this.getChannel(cmd.channel);
            _this.debug({
                type: 'log',
                log: {
                    direction: 'out',
                    channel: {
                        id: cmd.channel,
                        name: channel.name,
                        service: channel.service,
                    },
                    cmd: cmd,
                },
            });
            var cmdBuf = protocol_1.api.Command.encode(cmd).finish();
            var buffer = cmdBuf.buffer.slice(cmdBuf.byteOffset, cmdBuf.byteOffset + cmdBuf.length);
            if (_this.ws == null) {
                _this.onUnrecoverableError(new Error('Calling send on a closed client'));
                return;
            }
            _this.ws.send(buffer);
        };
        this.onSocketMessage = function (_a) {
            var data = _a.data;
            var d = new Uint8Array(data);
            var cmd = protocol_1.api.Command.decode(d);
            var channel = _this.getChannel(cmd.channel);
            _this.debug({
                type: 'log',
                log: {
                    direction: 'in',
                    channel: {
                        id: cmd.channel,
                        name: channel.name,
                        service: channel.service,
                    },
                    cmd: cmd,
                },
            });
            channel.handleCommand(cmd);
        };
        this.handleConnect = function () {
            _this.connectionState = types_1.ConnectionState.CONNECTED;
            _this.debug({ type: 'breadcrumb', message: 'connected!' });
            if (!_this.ws) {
                _this.onUnrecoverableError(new Error('Expected Websocket instance'));
                return;
            }
            var onClose = function (event) {
                if (_this.connectionState === types_1.ConnectionState.DISCONNECTED) {
                    _this.onUnrecoverableError(new Error('Got a close event on socket but client is in disconnected state'));
                    return;
                }
                _this.debug({
                    type: 'breadcrumb',
                    message: 'wsclose',
                    data: {
                        event: event,
                    },
                });
                _this.handleClose({
                    closeReason: ClientCloseReason.Disconnected,
                    wsEvent: event,
                });
            };
            _this.ws.onclose = onClose;
            _this.ws.onerror = onClose;
            _this.channelRequests.forEach(function (channelRequest) {
                _this.requestOpenChannel(channelRequest);
            });
        };
        this.handleClose = function (closeResult) {
            if (closeResult.closeReason !== ClientCloseReason.Error) {
                if (_this.connectionState === types_1.ConnectionState.DISCONNECTED) {
                    _this.onUnrecoverableError(new Error('handleClose is called but client already disconnected'));
                    return;
                }
                if (_this.ws && _this.fetchTokenAbortController) {
                    _this.onUnrecoverableError(new Error('fetchTokenAbortController and websocket exist simultaneously'));
                    return;
                }
            }
            _this.cleanupSocket();
            if (_this.retryTimeoutId) {
                clearTimeout(_this.retryTimeoutId);
                _this.retryTimeoutId = null;
            }
            if (_this.connectTimeoutId) {
                clearTimeout(_this.connectTimeoutId);
                _this.connectTimeoutId = null;
            }
            if (_this.fetchTokenAbortController) {
                _this.fetchTokenAbortController.abort();
                _this.fetchTokenAbortController = null;
            }
            var willClientReconnect = closeResult.closeReason === ClientCloseReason.Disconnected;
            _this.channelRequests.forEach(function (channelRequest) {
                var willChannelReconnect = willClientReconnect && !channelRequest.closeRequested;
                if (channelRequest.isOpen) {
                    var channel = _this.getChannel(channelRequest.channelId);
                    channel.handleClose({
                        initiator: 'client',
                        willReconnect: willChannelReconnect,
                    });
                    delete _this.channels[channelRequest.channelId];
                }
                else if (!willChannelReconnect) {
                    channelRequest.openChannelCb({
                        channel: null,
                        error: new Error('Failed to open'),
                        context: _this.connectOptions ? _this.connectOptions.context : null,
                    });
                }
                var cleanupCb = channelRequest.cleanupCb, closeRequested = channelRequest.closeRequested;
                channelRequest.channelId = null;
                channelRequest.isOpen = false;
                channelRequest.cleanupCb = null;
                channelRequest.closeRequested = false;
                if (cleanupCb) {
                    cleanupCb({
                        initiator: 'client',
                        willReconnect: willChannelReconnect,
                    });
                }
                if (closeRequested || channelRequest.closeRequested) {
                    _this.channelRequests = _this.channelRequests.filter(function (cr) { return cr !== channelRequest; });
                }
            });
            if (_this.channels[0]) {
                _this.channels[0].handleClose({
                    initiator: 'client',
                    willReconnect: willClientReconnect,
                });
                delete _this.channels[0];
            }
            if (Object.keys(_this.channels).length !== 0) {
                _this.channels = {};
                if (closeResult.closeReason !== ClientCloseReason.Error) {
                    _this.onUnrecoverableError(new Error('channels object should be empty after channelRequests and chan0 cleanup'));
                    return;
                }
            }
            if (_this.chan0CleanupCb) {
                _this.chan0CleanupCb({
                    initiator: 'client',
                    willReconnect: willClientReconnect,
                });
                _this.chan0CleanupCb = null;
            }
            else if (!willClientReconnect) {
                if (_this.chan0Cb) {
                    _this.chan0Cb({
                        channel: null,
                        error: new Error('Failed to open'),
                        context: _this.connectOptions ? _this.connectOptions.context : null,
                    });
                }
                else if (closeResult.closeReason !== ClientCloseReason.Error) {
                    _this.onUnrecoverableError(new Error('open should have been called before `handleClose`'));
                    return;
                }
            }
            _this.connectionState = types_1.ConnectionState.DISCONNECTED;
            if (!willClientReconnect) {
                _this.chan0Cb = null;
                _this.connectOptions = null;
                return;
            }
            _this.debug({
                type: 'breadcrumb',
                message: 'reconnecting',
            });
            _this.connect({ tryCount: 0, websocketFailureCount: 0 });
        };
        this.cleanupSocket = function () {
            var ws = _this.ws;
            _this.debug({
                type: 'breadcrumb',
                message: 'cleanupSocket',
                data: {
                    hasWs: Boolean(ws),
                    readyState: ws ? ws.readyState : null,
                    connectionState: _this.connectionState,
                },
            });
            if (!ws) {
                return;
            }
            _this.ws = null;
            ws.onmessage = null;
            ws.onclose = null;
            ws.onopen = null;
            ws.onerror = function () { };
            if (ws.readyState === 0 || ws.readyState === 1) {
                _this.debug({
                    type: 'breadcrumb',
                    message: 'wsclose',
                });
                ws.close();
            }
        };
        this.onUnrecoverableError = function (e) {
            _this.debug({
                type: 'breadcrumb',
                message: 'unrecoverable error',
                data: {
                    message: e.message,
                },
            });
            _this.redirectInitiatorURL = null;
            if (_this.connectionState !== types_1.ConnectionState.DISCONNECTED) {
                try {
                    _this.handleClose({
                        closeReason: ClientCloseReason.Error,
                        error: e,
                    });
                }
                catch (handleCloseErr) {
                    console.error('handleClose errored during unrecoverable error');
                    console.error(handleCloseErr);
                }
            }
            if (_this.userUnrecoverableErrorHandler) {
                _this.userUnrecoverableErrorHandler(e);
                return;
            }
            console.error('Please supply your own unrecoverable error handling function');
            throw e;
        };
        this.redirectInitiatorFallback = function () {
            if (!_this.connectionMetadata) {
                return _this.onUnrecoverableError(new Error("client's connectionMetadata is null when redirecting to initiator"));
            }
            if (!_this.connectOptions) {
                return _this.onUnrecoverableError(new Error("client's connectOptions is null when redirecting to initiator"));
            }
            if (!_this.chan0Cb) {
                return _this.onUnrecoverableError(new Error("client's chan0Cb is null when redirecting to initiator"));
            }
            var context = _this.connectOptions.context;
            var chan0Cb = _this.chan0Cb;
            var govalMetadata = {
                token: _this.connectionMetadata.token,
                conmanURL: _this.connectionMetadata.conmanURL,
                gurl: _this.connectionMetadata.gurl,
            };
            _this.redirectInitiatorURL = null;
            var fetchConnectionMetadataResult = __assign({ error: null }, govalMetadata);
            _this.close();
            _this.open({
                fetchConnectionMetadata: function () { return Promise.resolve(fetchConnectionMetadataResult); },
                WebSocketClass: WebSocket,
                context: context,
            }, chan0Cb);
        };
        this.handleRedirect = function (url) {
            _this.debug({
                type: 'breadcrumb',
                message: 'handling redirect',
                data: {
                    connectionMetadata: _this.connectionMetadata,
                },
            });
            if (!_this.connectionMetadata) {
                return _this.onUnrecoverableError(new Error("client's connectionMetadata is null when redirecting"));
            }
            if (!_this.connectOptions) {
                return _this.onUnrecoverableError(new Error("client's connectOptions is null when redirecting"));
            }
            if (!_this.chan0Cb) {
                return _this.onUnrecoverableError(new Error("client's chan0Cb is null when redirecting"));
            }
            var context = _this.connectOptions.context;
            var chan0Cb = _this.chan0Cb;
            var govalMetadata = {
                token: _this.connectionMetadata.token,
                conmanURL: _this.connectionMetadata.conmanURL,
                gurl: url,
            };
            _this.redirectInitiatorURL = _this.connectionMetadata.gurl;
            var fetchConnectionMetadataResult = __assign({ error: null }, govalMetadata);
            _this.close();
            _this.open({
                fetchConnectionMetadata: function () { return Promise.resolve(fetchConnectionMetadataResult); },
                WebSocketClass: WebSocket,
                context: context,
            }, chan0Cb);
        };
        this.ws = null;
        this.channels = {};
        this.connectOptions = null;
        this.chan0Cb = null;
        this.chan0CleanupCb = null;
        this.connectionState = types_1.ConnectionState.DISCONNECTED;
        this.debugFuncs = [];
        this.bootStatusFuncs = [];
        this.userUnrecoverableErrorHandler = null;
        this.channelRequests = [];
        this.retryTimeoutId = null;
        this.connectTimeoutId = null;
        this.fetchTokenAbortController = null;
        this.destroyed = false;
        this.connectionMetadata = null;
        this.redirectInitiatorURL = null;
        this.debug({ type: 'breadcrumb', message: 'constructor' });
    }
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=client.js.map