"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var jest_websocket_mock_1 = require("jest-websocket-mock");
var mock_socket_1 = require("mock-socket");
var types_1 = require("../types");
var genConnectionMetadata = require('../../debug/genConnectionMetadata');
jest.setTimeout(5000);
var genConnectionMetadataWithGurl = function (gurl) {
    var connectionMetadata = genConnectionMetadata();
    connectionMetadata.gurl = gurl;
    connectionMetadata.token = '';
    return connectionMetadata;
};
var port = 9751;
var testingClients = [];
afterAll(function () {
    testingClients.forEach(function (c) {
        c.destroy();
    });
});
describe('retry handling', function () {
    test('should not retry for user error', function (done) {
        var ctx = { username: 'zyzz' };
        var client = new __1.Client();
        var unrecoverableError = jest.fn();
        client.setUnrecoverableErrorHandler(function (e) {
            unrecoverableError(e.message);
            console.log('got unrecoverable error: ', e);
        });
        testingClients.push(client);
        var addr = 'ws://localhost:' + port;
        var server = new jest_websocket_mock_1.default(addr + '/wsv2/');
        var tryCount = 0;
        var connectionMetadata = genConnectionMetadataWithGurl(addr);
        client.open({
            fetchConnectionMetadata: function () {
                tryCount++;
                return Promise.resolve(__assign(__assign({}, connectionMetadata), { error: null }));
            },
            WebSocketClass: mock_socket_1.WebSocket,
            context: ctx,
        }, function (_a) {
            var error = _a.error;
            expect(tryCount).toBe(1);
            expect(error === null || error === void 0 ? void 0 : error.message).toBe('Failed to open');
            done();
            return function () { };
        });
        server.on('connection', function () {
            server.close({ code: types_1.CloseCode.USER_ERROR, reason: 'user error', wasClean: true });
        });
    });
    test('should retry for another machine', function (done) {
        var ctx = { username: 'zyzz' };
        var client = new __1.Client();
        var unrecoverableError = jest.fn();
        client.setUnrecoverableErrorHandler(function (e) {
            unrecoverableError(e.message);
            console.log('got unrecoverable error: ', e);
        });
        testingClients.push(client);
        var addr = 'ws://localhost:' + port;
        var server = new jest_websocket_mock_1.default(addr + '/wsv2/');
        var tryCount = 0;
        var connectionMetadata = genConnectionMetadataWithGurl(addr);
        client.open({
            fetchConnectionMetadata: function () {
                tryCount++;
                if (tryCount === 2) {
                    done();
                }
                return Promise.resolve(__assign(__assign({}, connectionMetadata), { error: null }));
            },
            WebSocketClass: mock_socket_1.WebSocket,
            context: ctx,
        }, function () { });
        server.on('connection', function () {
            server.close({
                code: types_1.CloseCode.TRY_ANOTHER_MACHINE,
                reason: 'try another machine',
                wasClean: true,
            });
        });
    });
});
//# sourceMappingURL=retry.test.js.map