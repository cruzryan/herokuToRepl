import type { api } from '@replit/protocol';
import type { Channel } from './channel';
export declare enum ConnectionState {
    CONNECTING = 0,
    CONNECTED = 1,
    DISCONNECTED = 2
}
export declare enum FetchConnectionMetadataError {
    Aborted = "Aborted",
    Retriable = "Retriable"
}
export interface GovalMetadata {
    token: string;
    gurl: string;
    conmanURL: string;
}
export declare type Result<Res, Err = Error> = (Res & {
    error: null;
}) | {
    error: Err;
};
export declare type FetchConnectionMetadataResult = Result<GovalMetadata, Error | FetchConnectionMetadataError>;
export interface ConnectOptions<Ctx> {
    fetchConnectionMetadata: (abortSignal: AbortSignal) => Promise<FetchConnectionMetadataResult>;
    timeout: number | null;
    WebSocketClass?: typeof WebSocket;
    context: Ctx;
    reuseConnectionMetadata: boolean;
    pollingHost?: string;
    getNextRetryDelayMs: (tryCount: number) => number;
}
export interface UrlOptions {
    secure: boolean;
    host: string;
    port: string;
}
export interface OpenOptions<Ctx> extends Partial<ConnectOptions<Ctx>> {
    fetchConnectionMetadata: (abortSignal: AbortSignal) => Promise<FetchConnectionMetadataResult>;
    urlOptions?: UrlOptions;
    context: Ctx;
}
export declare type DebugLogBreadcrumb<Ctx> = {
    type: 'breadcrumb';
    message: 'constructor' | 'openChanres' | 'connected!' | 'user close' | 'cancel timeout' | 'reset timeout' | 'connect timeout' | 'polling fallback' | 'reconnecting' | 'destroy';
} | {
    type: 'breadcrumb';
    message: 'open';
    data: {
        polling: false;
    };
} | {
    type: 'breadcrumb';
    message: 'connecting';
    data: {
        connectionState: ConnectionState;
        connectTries: number;
        websocketFailureCount: number;
        readyState: WebSocket['readyState'] | undefined;
        chan0CbExists: boolean;
    };
} | {
    type: 'breadcrumb';
    message: 'requestOpenChannel';
    data?: {
        name: ChannelOptions<Ctx>['name'];
        service: ChannelOptions<Ctx>['service'];
        action: ChannelOptions<Ctx>['action'];
    };
} | {
    type: 'breadcrumb';
    message: 'requestChannelClose';
    data: {
        id: number;
        name: ChannelOptions<Ctx>['name'];
        service: ChannelOptions<Ctx>['service'];
    };
} | {
    type: 'breadcrumb';
    message: 'requestChannelClose:chan0Closed';
    data: {
        id: number;
        name: ChannelOptions<Ctx>['name'];
        service: ChannelOptions<Ctx>['service'];
    };
} | {
    type: 'breadcrumb';
    message: 'requestChannelClose:closeChanRes';
    data: {
        id: number;
        name: ChannelOptions<Ctx>['name'];
        service: ChannelOptions<Ctx>['service'];
        closeStatus: api.CloseChannelRes.Status;
    };
} | {
    type: 'breadcrumb';
    message: 'retrying';
    data: {
        connectionState: ConnectionState;
        connectTries: number;
        websocketFailureCount: number;
        error: Error;
        wsReadyState?: WebSocket['readyState'];
    };
} | {
    type: 'breadcrumb';
    message: 'redirectInitiatorFallback';
    data: {
        connectionState: ConnectionState;
        connectTries: number;
        websocketFailureCount: number;
        error: Error;
        wsReadyState?: WebSocket['readyState'];
    };
} | {
    type: 'breadcrumb';
    message: 'containerState';
    data: api.ContainerState.State;
} | {
    type: 'breadcrumb';
    message: 'wsclose';
    data?: {
        event: CloseEvent | Event;
    };
} | {
    type: 'breadcrumb';
    message: 'cleanupSocket';
    data: {
        hasWs: boolean;
        readyState: WebSocket['readyState'] | null;
        connectionState: ConnectionState;
    };
} | {
    type: 'breadcrumb';
    message: 'unrecoverable error';
    data: {
        message: string;
    };
} | {
    type: 'breadcrumb';
    message: 'handling redirect';
    data: {
        connectionMetadata: GovalMetadata | null;
    };
};
export declare type DebugLog<Ctx> = DebugLogBreadcrumb<Ctx> | {
    type: 'log';
    log: {
        direction: 'in' | 'out';
        channel: {
            id: number;
            name?: ChannelOptions<Ctx>['name'];
            service?: ChannelOptions<Ctx>['service'];
        };
        cmd: api.Command;
    };
};
export declare type ChannelCloseReason = {
    initiator: 'client';
    willReconnect: boolean;
} | {
    initiator: 'channel';
    willReconnect: false;
};
interface ServiceThunk<Ctx> {
    (context: Ctx): string;
}
export interface ChannelOptions<Ctx> {
    name?: string;
    service: string | ServiceThunk<Ctx>;
    action?: api.OpenChannel.Action;
    skip?: (context: Ctx) => boolean;
}
export declare type OpenChannelCb<Ctx> = (res: {
    error: null;
    channel: Channel;
    context: Ctx;
} | {
    error: Error;
    channel: null;
    context: Ctx | null;
}) => void | ((reason: ChannelCloseReason) => void);
export interface RequestResult extends api.Command {
    channelClosed?: ChannelCloseReason;
}
export declare const CloseCode: {
    INVALID_UPSTREAM_RESPONSE: number;
    POLICY_VIOLATION: number;
    FIREWALL_DENIED: number;
    TRY_ANOTHER_MACHINE: number;
    USER_ERROR: number;
};
export {};
